<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>录音</title>
    <script src="./lib/react.development.js"></script>
    <script src="./lib/react-dom.development.js"></script>
    <script src="./lib/babel.min.js"></script>
    <script type="text/javascript" src="./lib/recorder.js"></script>
    <script type="text/javascript" src="./js/transform.js"></script>
    <script type="text/javascript" src="./js/exception.js"></script>
    <script type="text/javascript" src="./js/player.js"></script>
    <link href="./bootstrap.css" rel="stylesheet" />
</head>

<body>
    <div id="root">


    </div>
    <script src="./lib/jquery.min.js"></script>
    <script type="text/babel">

        let recorder = null;
        let playTimer = null;
        let oCanvas = null;
        let ctx = null;
        let drawRecordId = null;
        let pCanvas = null;
        let pCtx = null;
        let drawPlayId = null;

        const sampleRateOptions = [
            { text: '8000', value: 8000 },
            { text: '16000', value: 16000 },
            { text: '22050', value: 22050 },
            { text: '24000', value: 24000 },
            { text: '44100', value: 44100 },
            { text: '48000', value: 48000 },
        ];

        const sampleBitOptions = [
            { text: '8', value: 8 },
            { text: '16', value: 16 },
        ];

        const numChannelOptions = [
            { text: '单', value: 1 },
            { text: '双', value: 2 },
        ];


        class App extends React.Component {
            state = {
                sampleBit: 16,
                sampleRate: 16000,
                numChannel: 1,
                compiling: false,
                isRecording: false,     // 是否正在录音
                duration: 0,
                fileSize: 0,
                vol: 0,
            }

            collectData = () => {
                return {
                    sampleBits: this.state.sampleBit,
                    sampleRate: this.state.sampleRate,
                    numChannels: this.state.numChannel,
                    compiling: this.state.compiling,       // 是否开启边录音边转化（后期改用web worker）
                };
            }

            // getPermission = () => {
            //     if (!recorder) {
            //         recorder = new Recorder(config);
            //     }
            //     recorder.getPermission().then(() => {
            //         console.log('给权限了');
            //     }, (error) => {
            //         console.log(`${error.name} : ${error.message}`);
            //     });
            // }

            startRecord = () => {
                this.clearPlay();

                const config = this.collectData();

                if (!recorder) {
                    recorder = new Recorder(config);

                    recorder.onprocess = function (duration) {
                        // this.setState({
                        //     duration: duration.toFixed(5),
                        // });
                        // 推荐使用 onprogress
                    }

                    recorder.onprogress = (params) => {
                        // console.log(recorder.duration);
                        // console.log(recorder.fileSize);

                        this.setState({
                            duration: params.duration.toFixed(5),
                            fileSize: params.fileSize,
                            vol: params.vol.toFixed(2)
                        });
                        // 此处控制数据的收集频率
                        if (config.compiling) {
                            console.log('音频总数据：', params.data);
                        }
                    }

                    recorder.onplay = () => {
                        console.log('%c回调监听，开始播放音频', 'color: #2196f3')
                    }
                    recorder.onpauseplay = () => {
                        console.log('%c回调监听，暂停播放音频', 'color: #2196f3')
                    }
                    recorder.onresumeplay = () => {
                        console.log('%c回调监听，恢复播放音频', 'color: #2196f3')
                    }
                    recorder.onstopplay = () => {
                        console.log('%c回调监听，停止播放音频', 'color: #2196f3')
                    }
                    recorder.onplayend = () => {
                        console.log('%c回调监听，音频已经完成播放', 'color: #2196f3')
                        // 播放结束后，停止绘制canavs
                        this.stopDrawPlay();
                    }

                    // 边播边放的 定时获取录音的数据并播放
                    config.compiling && (playTimer = setInterval(() => {
                        if (!recorder) {
                            return;
                        }

                        let newData = recorder.getNextData();
                        if (!newData.length) {
                            return;
                        }
                        let byteLength = newData[0].byteLength
                        let buffer = new ArrayBuffer(newData.length * byteLength)
                        let dataView = new DataView(buffer)

                        // 数据合并
                        for (let i = 0, iLen = newData.length; i < iLen; ++i) {
                            for (let j = 0, jLen = newData[i].byteLength; j < jLen; ++j) {
                                dataView.setInt8(i * byteLength + j, newData[i].getInt8(j))
                            }
                        }

                        // 将录音数据转成WAV格式，并播放
                        let a = encodeWAV(dataView, config.sampleRate, config.sampleRate, config.numChannels, config.sampleBits)
                        let blob = new Blob([a], { type: 'audio/wav' });

                        blob.arrayBuffer().then((arraybuffer) => {
                            Player.play(arraybuffer);
                        });
                    }, 3000))
                } else {
                    recorder.stop();
                }

                recorder.start().then(() => {
                    console.log('开始录音');
                }, (error) => {
                    console.log(`异常了,${error.name}:${error.message}`);
                });
                // 开始绘制canvas
                this.drawRecord();
            }

            drawRecord = () => {
                // 用requestAnimationFrame稳定60fps绘制
                drawRecordId = requestAnimationFrame(this.drawRecord);

                // 实时获取音频大小数据
                let dataArray = recorder.getRecordAnalyseData(),
                    bufferLength = dataArray.length;

                // 填充背景色
                ctx.fillStyle = 'rgb(200, 200, 200)';
                ctx.fillRect(0, 0, oCanvas.width, oCanvas.height);

                // 设定波形绘制颜色
                ctx.lineWidth = 2;
                ctx.strokeStyle = 'rgb(0, 0, 0)';

                ctx.beginPath();

                var sliceWidth = oCanvas.width * 1.0 / bufferLength, // 一个点占多少位置，共有bufferLength个点要绘制
                    x = 0;          // 绘制点的x轴位置

                for (var i = 0; i < bufferLength; i++) {
                    var v = dataArray[i] / 128.0;
                    var y = v * oCanvas.height / 2;

                    if (i === 0) {
                        // 第一个点
                        ctx.moveTo(x, y);
                    } else {
                        // 剩余的点
                        ctx.lineTo(x, y);
                    }
                    // 依次平移，绘制所有点
                    x += sliceWidth;
                }

                ctx.lineTo(oCanvas.width, oCanvas.height / 2);
                ctx.stroke();
            }

            drawPlay = () => {
                // 用requestAnimationFrame稳定60fps绘制
                drawPlayId = requestAnimationFrame(this.drawPlay);

                // 实时获取音频大小数据
                let dataArray = recorder.getPlayAnalyseData(),
                    bufferLength = dataArray.length;

                // 填充背景色
                pCtx.fillStyle = 'rgb(200, 200, 200)';
                pCtx.fillRect(0, 0, pCanvas.width, pCanvas.height);

                // 设定波形绘制颜色
                pCtx.lineWidth = 2;
                pCtx.strokeStyle = 'rgb(0, 0, 0)';

                pCtx.beginPath();

                var sliceWidth = pCanvas.width * 1.0 / bufferLength, // 一个点占多少位置，共有bufferLength个点要绘制
                    x = 0;          // 绘制点的x轴位置

                for (var i = 0; i < bufferLength; i++) {
                    var v = dataArray[i] / 128.0;
                    var y = v * pCanvas.height / 2;

                    if (i === 0) {
                        // 第一个点
                        pCtx.moveTo(x, y);
                    } else {
                        // 剩余的点
                        pCtx.lineTo(x, y);
                    }
                    // 依次平移，绘制所有点
                    x += sliceWidth;
                }

                pCtx.lineTo(pCanvas.width, pCanvas.height / 2);
                pCtx.stroke();
            }

            endRecord = () => {
                recorder && recorder.stop();
                console.log('结束录音');
                drawRecordId && cancelAnimationFrame(drawRecordId);
                drawRecordId = null;
            }
            playRecord = () => {
                recorder && recorder.play();
                drawRecordId && cancelAnimationFrame(drawRecordId);
                drawRecordId = null;
                console.log('播放录音');
                recorder && this.drawPlay();
                // setInterval(() => {
                //     recorder.getPlayTime()
                // }, 500)
            }

            clearPlay = () => {
                if (playTimer) {
                    clearInterval(playTimer);
                    playTimer = null;
                }
                if (drawRecordId) {
                    cancelAnimationFrame(drawRecordId);
                    drawRecordId = null;
                }
                this.stopDrawPlay();
            }
            stopDrawPlay = () => {
                drawPlayId && cancelAnimationFrame(drawPlayId);
                drawPlayId = null;
            }
            stopPlay = () => {
                this.clearPlay();
                recorder && recorder.stopPlay();
                console.log('停止播放');
                this.stopDrawPlay();
            }
            destroyRecord = () => {
                this.clearPlay();
                if (recorder) {
                    recorder.destroy().then(() => {
                        console.log('销毁实例');
                        recorder = null;
                        drawRecordId && cancelAnimationFrame(drawRecordId);
                        this.stopDrawPlay();
                    });
                }
            }

            // 将数据发送给server
            sendWavBlobToServer = () => {
                if (recorder) {
                    // converts blob to base64
                    var blobToBase64 = function (blob, cb) {
                        var reader = new FileReader();
                        reader.onload = function () {
                            var dataUrl = reader.result;
                            var base64 = dataUrl.split(',')[1];
                            cb(base64);
                        };
                        reader.readAsDataURL(blob);
                    };

                    blobToBase64(recorder.getWAVBlob(), function (base64) { // encode
                        var update = { 'blob': base64 };

                        $.ajax({
                            url: "/post_audio",
                            // dataType: "json",
                            data: JSON.stringify(update),
                            type: "POST",
                            cache: false,
                            success: function (data) {
                                if (data == "refuse") {
                                    alert("语音识别中，请稍后！");
                                }
                            },
                            error: function (data, status, e) {
                                alert("error: ", data);
                            }
                        });

                    });


                    // var fd = new FormData();
                    // fd.append('fname', 'test.wav');
                    // fd.append('data', recorder.getWAVBlob());
                    // $.ajax({
                    //     url: "/post_audio",
                    //     data: fd,
                    //     type: "POST",
                    //     processData: false,
                    //     contentType: false,
                    //     success: function (data) {
                    //         if (data == "refuse") {
                    //             alert("语音识别中，请稍后！");
                    //         }
                    //     },
                    //     error: function (data, status, e) {
                    //         alert("error: ", data);
                    //     }
                    // });
                }
            }


            componentDidMount() {
                oCanvas = document.getElementById('canvas');
                ctx = oCanvas.getContext("2d");
                pCanvas = document.getElementById('playChart');
                pCtx = pCanvas.getContext("2d");
            }



            render() {
                return (
                    <div className="App" style={{ margin: '20px 0' }}>

                        <br />
                        <br />
                        <div>

                            <button onClick={this.startRecord}>
                                录音开启
                            </button>
                            <button onClick={this.endRecord}>
                                录音停止
                            </button>
                        </div>
                        <br />
                        <br />
                        <span>录音时长(秒)</span>
                        <span>{this.state.duration}</span>
                        
                        <br />
                        <br />
                        <div>
                            <span>录音：</span>
                            <canvas id="canvas"></canvas>
                            <br />
                            <br />
                            <span>播放：</span>
                            <canvas id="playChart"></canvas>
                        </div>
                        <br />
                        <br />
                        <div>
                            <button onClick={this.playRecord}>
                                录音播放
                            </button>
                            <button onClick={this.stopPlay}>
                                停止播放
                            </button>
                            <button onClick={this.sendWavBlobToServer}>
                                发送音频
                            </button>
                        </div>
                        <br />
                        <br />
                    </div>
                );
            }
        }


        ReactDOM.render(
            <App />,
            document.getElementById('root')
        );
    </script>
</body>

</html>